/**
 * Core Philosophy: This ruleset enforces a strict, two-tiered security model.
 * 1. User Ownership: Administrator profiles in `/admin_profiles` and user profiles
 *    in `/users` are private and can only be written by the owner of that profile.
 * 2. Role-Based Access: A separate `/roles_admin` collection acts as a lookup
 *    table. The existence of a document at `/roles_admin/{uid}` grants a user
 *    admin privileges, which are required to view or manage the list of all users and admins.
 *
 * Data Structure:
 * - /admin_profiles/{adminId}: Contains the detailed profile data for a specific
 *   administrator, where `{adminId}` is their Firebase Auth UID.
 * - /roles_admin/{uid}: Contains simple "flag" documents. If a document exists at
 *   this path, the user with the corresponding UID is considered an admin.
 * - /users/{userId}: Contains public profile data for a specific user.
 * - /users/{userId}/favorites/{propertyId}: Stores a user's favorite properties.
 * - /users/{userId}/documents/{documentId}: Stores a user's uploaded documents.
 * - /users/{userId}/savedSearches/{searchId}: Stores a user's saved search filters.
 * - /bookings/{bookingId}: Contains booking details.
 * - /properties/{propertyId}: Contains property details.
 * - /visits/{visitId}: Contains visit request details.
 * - /announcements/{announcementId}: Contains system-wide announcements.
 *
 * Key Security Decisions:
 * - Admin Listing Disabled for Non-Admins: Non-administrative users cannot list
 *   or discover who the administrators or other users are.
 * - Privilege Escalation Prevention: A user cannot grant themselves admin status.
 *   Only an existing admin can create or delete documents in the `/roles_admin`
 *   collection (though initial creation is relaxed for the first admin).
 * - Self-Service Profile Management: Admins and Users are responsible for creating and
 *   maintaining their own profile data.
 * - Booking Ownership: Users can only create and view their own bookings.
 * - Favorite Ownership: Users can only manage their own list of favorites.
 * - Document Ownership: Users can only manage their own documents.
 * - Saved Search Ownership: Users can only manage their own saved searches.
 * - Visit Ownership: Users can create visits. They can view their own visits.
 *   Property owners can view and manage visits for their properties.
 * - Announcement Management: Only admins can create, read, and manage announcements.
 *
 * Denormalization for Authorization:
 * The `/roles_admin` collection is a classic example of denormalization for
 * authorization. Instead of embedding a role field in a user profile and requiring
 * a slow `get()` call, we use a separate collection that allows for a fast and

 * efficient `exists()` check to determine a user's admin status from any rule.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for readable and reusable logic
    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }
    
    /**
     * Checks if the user is authenticated and has a verified email.
     */
    function isVerified() {
      return isSignedIn() && request.auth.token.email_verified == true;
    }

    /**
     * Checks if the requesting user's UID matches the document's owner ID.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the requesting user owns the document and the document already exists.
     * Crucial for preventing writes to non-existent paths on update/delete.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Checks if the requesting user is an administrator by verifying the
     * existence of a role document in the `/roles_admin` collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Checks if the user is the designated super-admin.
     */
    function isSuperAdmin() {
      return isSignedIn() && request.auth.token.email == 'samuelknimelyjr@gmail.com';
    }
    
    /**
     * Checks if the user is the owner of a given property.
     */
    function isPropertyOwner(propertyId) {
      let propertyDoc = get(/databases/$(database)/documents/properties/$(propertyId));
      return isSignedIn() && propertyDoc.data.owner.id == request.auth.uid;
    }


    /**
     * @description Manages individual user profiles and their subcollections.
     * @path /users/{userId}
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin() || isSuperAdmin();
      allow list: if isAdmin() || isSuperAdmin();
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if (isOwner(userId) || isAdmin() || isSuperAdmin()) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId) || isAdmin() || isSuperAdmin();
      
      /**
       * @description Manages a user's favorite properties.
       * @path /users/{userId}/favorites/{propertyId}
       * @allow (read, write) A user can manage their own favorites list.
       * @deny (read, write) A user cannot access another user's favorites.
       */
      match /favorites/{propertyId} {
        allow read, write: if isVerified() && isOwner(userId);
      }
      
      /**
       * @description Manages a user's uploaded documents.
       * @path /users/{userId}/documents/{documentId}
       * @allow (read, write) A user can manage their own documents.
       * @deny (read, write) A user cannot access another user's documents.
       */
      match /documents/{documentId} {
        allow read, write: if isVerified() && isOwner(userId);
      }
      
      /**
       * @description Manages a user's saved search filters.
       * @path /users/{userId}/savedSearches/{searchId}
       * @allow (read, write) A user can manage their own saved searches.
       * @deny (read, write) A user cannot access another user's saved searches.
       */
      match /savedSearches/{searchId} {
        allow read, write: if isVerified() && isOwner(userId);
      }
    }

    /**
     * @description Manages individual administrator profiles. Access is strictly limited to the profile owner.
     * @path /admin_profiles/{adminId}
     * @allow (get) A signed-in admin with UID 'admin123' reads their own profile at `/admin_profiles/admin123`.
     * @deny (get) A different user, 'user456', tries to read the profile at `/admin_profiles/admin123`.
     * @principle Restricts access to a user's own data tree, enforcing data privacy.
     */
    match /admin_profiles/{adminId} {
      allow get: if isOwner(adminId) || isSuperAdmin();
      allow list: if isAdmin() || isSuperAdmin();
      allow create: if isOwner(adminId) && request.resource.data.id == adminId;
      allow update: if (isExistingOwner(adminId) || isSuperAdmin()) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(adminId) || isSuperAdmin();
    }

    /**
     * @description Manages admin role flags. The existence of a document grants admin privileges.
     * @path /roles_admin/{uid}
     * @allow (create) An existing admin creates a role document for a new user at `/roles_admin/newUser789`. The first admin can self-assign.
     * @deny (create) A non-admin user attempts to create a role document for themselves at `/roles_admin/nonAdminUser`.
     * @principle Enforces role-based access control, preventing unauthorized privilege escalation.
     */
    match /roles_admin/{uid} {
      allow get: if isOwner(uid) || isAdmin() || isSuperAdmin();
      allow list: if isAdmin() || isSuperAdmin();
      allow create: if isOwner(uid) && (!exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid)) || isAdmin() || isSuperAdmin());
      allow update: if false;
      allow delete: if (isAdmin() || isSuperAdmin()) && resource != null;
    }

    /**
     * @description Manages booking data with role-based access.
     * @path /bookings/{bookingId}
     */
    match /bookings/{bookingId} {
        // Admins can read any booking. Users can read their own or bookings for properties they own.
        allow read: if isVerified() && (isAdmin() || isSuperAdmin() || isOwner(resource.data.userId) || isPropertyOwner(resource.data.propertyId));
        // Admins can list all bookings.
        allow list: if isVerified() && (isAdmin() || isSuperAdmin());
        allow create: if isVerified() && isOwner(request.resource.data.userId);
        allow update, delete: if isVerified() && (isOwner(resource.data.userId) || isPropertyOwner(resource.data.propertyId) || isAdmin() || isSuperAdmin());
    }
    
    /**
     * @description Manages property listings.
     * @path /properties/{propertyId}
     */
    match /properties/{propertyId} {
      // Admins and owners can read properties regardless of status. Public users can only see approved properties.
      allow read: if (isAdmin() || isSuperAdmin()) || (isVerified() && isOwner(resource.data.owner.id)) || resource.data.status == 'approved';
      
      // Admins can list all properties. Public users can only list approved properties (via query).
      allow list: if isVerified() && (isAdmin() || isSuperAdmin());
      

      // Users can create properties, but they must be 'pending'.
      allow create: if isVerified() && isOwner(request.resource.data.owner.id) && request.resource.data.status == 'pending';
      
      // Owners can update their own properties, but cannot change the status.
      allow update: if isVerified() && isOwner(resource.data.owner.id) && request.resource.data.status == resource.data.status;
      
      // Admins can update any field, but only the Super Admin can change the status.
      allow update: if isAdmin() && (request.resource.data.status == resource.data.status || isSuperAdmin());
      
      // Owners or Admins can delete.
      allow delete: if (isVerified() && isOwner(resource.data.owner.id)) || isAdmin() || isSuperAdmin();
    }
    
    /**
     * @description Manages visit requests for properties.
     * @path /visits/{visitId}
     */
    match /visits/{visitId} {
        allow create: if isVerified() && isOwner(request.resource.data.userId);
        
        allow read: if isVerified() && (isOwner(resource.data.userId) || isAdmin() || isSuperAdmin() || isPropertyOwner(resource.data.propertyId));
        
        allow list: if isVerified() && (isAdmin() || isSuperAdmin() ||
                       (request.query.where.size() > 0 && request.query.where[0][0] == 'userId' && request.query.where[0][2] == request.auth.uid) ||
                       (request.query.where.size() > 0 && request.query.where[0][0] == 'propertyId' && isPropertyOwner(request.query.where[0][2])));

        allow update: if (isVerified() && isPropertyOwner(resource.data.propertyId)) || isAdmin() || isSuperAdmin();

        allow delete: if (isVerified() && isOwner(resource.data.userId)) || (isVerified() && isPropertyOwner(resource.data.propertyId)) || isAdmin() || isSuperAdmin();
    }

    /**
     * @description Manages global application settings.
     * @path /settings/global
     */
    match /settings/global {
      allow read, write: if isAdmin() || isSuperAdmin();
    }

    /**
     * @description Manages system-wide announcements.
     * @path /announcements/{announcementId}
     */
    match /announcements/{announcementId} {
      allow read: if isSignedIn();
      allow write: if isAdmin() || isSuperAdmin();
    }

    /**
     * @description Manages support tickets.
     * @path /tickets/{ticketId}
     */
    match /tickets/{ticketId} {
      allow create: if isSignedIn();
      allow read, write: if isAdmin() || isSuperAdmin();
      allow list: if isAdmin() || isSuperAdmin();
    }
  }
}

    