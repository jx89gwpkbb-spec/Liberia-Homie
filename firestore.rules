/**
 * Core Philosophy: This ruleset enforces a strict, two-tiered security model.
 * 1. User Ownership: Administrator profiles in `/admin_profiles` and user profiles
 *    in `/users` are private and can only be written by the owner of that profile.
 * 2. Role-Based Access: A separate `/roles_admin` collection acts as a lookup
 *    table. The existence of a document at `/roles_admin/{uid}` grants a user
 *    admin privileges, which are required to view or manage the list of all users and admins.
 *
 * Data Structure:
 * - /admin_profiles/{adminId}: Contains the detailed profile data for a specific
 *   administrator, where `{adminId}` is their Firebase Auth UID.
 * - /roles_admin/{uid}: Contains simple "flag" documents. If a document exists at
 *   this path, the user with the corresponding UID is considered an admin.
 * - /users/{userId}: Contains public profile data for a specific user.
 * - /bookings/{bookingId}: Contains booking details.
 *
 * Key Security Decisions:
 * - Admin Listing Disabled for Non-Admins: Non-administrative users cannot list
 *   or discover who the administrators or other users are.
 * - Privilege Escalation Prevention: A user cannot grant themselves admin status.
 *   Only an existing admin can create or delete documents in the `/roles_admin`
 *   collection (though initial creation is relaxed for the first admin).
 * - Self-Service Profile Management: Admins and Users are responsible for creating and
 *   maintaining their own profile data.
 * - Booking Ownership: Users can only create and view their own bookings.
 *
 * Denormalization for Authorization:
 * The `/roles_admin` collection is a classic example of denormalization for
 * authorization. Instead of embedding a role field in a user profile and requiring
 * a slow `get()` call, we use a separate collection that allows for a fast and
 * efficient `exists()` check to determine a user's admin status from any rule.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for readable and reusable logic
    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the requesting user's UID matches the document's owner ID.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the requesting user owns the document and the document already exists.
     * Crucial for preventing writes to non-existent paths on update/delete.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Checks if the requesting user is an administrator by verifying the
     * existence of a role document in the `/roles_admin` collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * @description Manages individual user profiles.
     * @path /users/{userId}
     * @allow (get) A signed-in user 'user123' can read their own profile at `/users/user123`. Admins can read any profile.
     * @deny (list) A non-admin user cannot list all users.
     * @principle Enforces data privacy while allowing admin oversight.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages individual administrator profiles. Access is strictly limited to the profile owner.
     * @path /admin_profiles/{adminId}
     * @allow (get) A signed-in admin with UID 'admin123' reads their own profile at `/admin_profiles/admin123`.
     * @deny (get) A different user, 'user456', tries to read the profile at `/admin_profiles/admin123`.
     * @principle Restricts access to a user's own data tree, enforcing data privacy.
     */
    match /admin_profiles/{adminId} {
      allow get: if isOwner(adminId);
      allow list: if isOwner(adminId);
      allow create: if isOwner(adminId) && request.resource.data.id == adminId;
      allow update: if isExistingOwner(adminId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(adminId);
    }

    /**
     * @description Manages admin role flags. The existence of a document grants admin privileges.
     * @path /roles_admin/{uid}
     * @allow (create) An existing admin creates a role document for a new user at `/roles_admin/newUser789`. The first admin can self-assign.
     * @deny (create) A non-admin user attempts to create a role document for themselves at `/roles_admin/nonAdminUser`.
     * @principle Enforces role-based access control, preventing unauthorized privilege escalation.
     */
    match /roles_admin/{uid} {
      allow get: if isOwner(uid) || isAdmin();
      allow list: if isAdmin();
      allow create: if isOwner(uid) && !exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
      allow update: if false;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Manages property bookings.
     * @path /bookings/{bookingId}
     * @allow (create) A signed-in user can create a booking for themselves.
     * @allow (read) A user can read their own bookings. Admins can read all bookings.
     * @deny (update, delete) Bookings are immutable once created for this example.
     */
    match /bookings/{bookingId} {
      allow create: if request.auth.uid == request.resource.data.userId;
      allow read: if request.auth.uid == resource.data.userId || isAdmin();
      allow list: if isAdmin() || (request.query.where.userId is string && request.query.where.userId == request.auth.uid);
      allow update, delete: if false;
    }
  }
}
