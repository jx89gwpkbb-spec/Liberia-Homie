/**
 * Core Philosophy: This ruleset enforces a strict, two-tiered security model.
 * 1. User Ownership: Administrator profiles in `/admin_profiles` and user profiles
 *    in `/users` are private and can only be written by the owner of that profile.
 * 2. Role-Based Access: A separate `/roles_admin` collection acts as a lookup
 *    table. The existence of a document at `/roles_admin/{uid}` grants a user
 *    admin privileges, which are required to view or manage the list of all users and admins.
 *
 * Data Structure:
 * - /admin_profiles/{adminId}: Contains the detailed profile data for a specific
 *   administrator, where `{adminId}` is their Firebase Auth UID.
 * - /roles_admin/{uid}: Contains simple "flag" documents. If a document exists at
 *   this path, the user with the corresponding UID is considered an admin.
 * - /users/{userId}: Contains public profile data for a specific user.
 * - /users/{userId}/favorites/{propertyId}: Stores a user's favorite properties.
 * - /users/{userId}/documents/{documentId}: Stores a user's uploaded documents.
 * - /users/{userId}/savedSearches/{searchId}: Stores a user's saved search filters.
 * - /bookings/{bookingId}: Contains booking details.
 * - /properties/{propertyId}: Contains property details.
 * - /visits/{visitId}: Contains visit request details.
 * - /announcements/{announcementId}: Contains system-wide announcements.
 *
 * Key Security Decisions:
 * - Admin Listing Disabled for Non-Admins: Non-administrative users cannot list
 *   or discover who the administrators or other users are.
 * - Privilege Escalation Prevention: A user cannot grant themselves admin status.
 *   Only an existing admin can create or delete documents in the `/roles_admin`
 *   collection (though initial creation is relaxed for the first admin).
 * - Self-Service Profile Management: Admins and Users are responsible for creating and
 *   maintaining their own profile data.
 * - Booking Ownership: Users can only create and view their own bookings.
 * - Favorite Ownership: Users can only manage their own list of favorites.
 * - Document Ownership: Users can only manage their own documents.
 * - Saved Search Ownership: Users can only manage their own saved searches.
 * - Visit Ownership: Users can create visits. They can view their own visits.
 *   Property owners can view and manage visits for their properties.
 * - Announcement Management: Only admins can create, read, and manage announcements.
 *
 * Denormalization for Authorization:
 * The `/roles_admin` collection is a classic example of denormalization for
 * authorization. Instead of embedding a role field in a user profile and requiring
 * a slow `get()` call, we use a separate collection that allows for a fast and
 * efficient `exists()` check to determine a user's admin status from any rule.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for readable and reusable logic
    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the requesting user's UID matches the document's owner ID.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the requesting user owns the document and the document already exists.
     * Crucial for preventing writes to non-existent paths on update/delete.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Checks if the requesting user is an administrator by verifying the
     * existence of a role document in the `/roles_admin` collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }
    
    /**
     * Checks if the user is the owner of a given property.
     */
    function isPropertyOwner(propertyId) {
      return isSignedIn() && get(/databases/$(database)/documents/properties/$(propertyId)).data.owner.id == request.auth.uid;
    }


    /**
     * @description Manages individual user profiles and their subcollections.
     * @path /users/{userId}
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
      
      /**
       * @description Manages a user's favorite properties.
       * @path /users/{userId}/favorites/{propertyId}
       * @allow (read, write) A user can manage their own favorites list.
       * @deny (read, write) A user cannot access another user's favorites.
       */
      match /favorites/{propertyId} {
        allow read, write: if isOwner(userId);
      }
      
      /**
       * @description Manages a user's uploaded documents.
       * @path /users/{userId}/documents/{documentId}
       * @allow (read, write) A user can manage their own documents.
       * @deny (read, write) A user cannot access another user's documents.
       */
      match /documents/{documentId} {
        allow read, write: if isOwner(userId);
      }
      
      /**
       * @description Manages a user's saved search filters.
       * @path /users/{userId}/savedSearches/{searchId}
       * @allow (read, write) A user can manage their own saved searches.
       * @deny (read, write) A user cannot access another user's saved searches.
       */
      match /savedSearches/{searchId} {
        allow read, write: if isOwner(userId);
      }
    }

    /**
     * @description Manages individual administrator profiles. Access is strictly limited to the profile owner.
     * @path /admin_profiles/{adminId}
     * @allow (get) A signed-in admin with UID 'admin123' reads their own profile at `/admin_profiles/admin123`.
     * @deny (get) A different user, 'user456', tries to read the profile at `/admin_profiles/admin123`.
     * @principle Restricts access to a user's own data tree, enforcing data privacy.
     */
    match /admin_profiles/{adminId} {
      allow get: if isOwner(adminId);
      allow list: if isOwner(adminId);
      allow create: if isOwner(adminId) && request.resource.data.id == adminId;
      allow update: if isExistingOwner(adminId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(adminId);
    }

    /**
     * @description Manages admin role flags. The existence of a document grants admin privileges.
     * @path /roles_admin/{uid}
     * @allow (create) An existing admin creates a role document for a new user at `/roles_admin/newUser789`. The first admin can self-assign.
     * @deny (create) A non-admin user attempts to create a role document for themselves at `/roles_admin/nonAdminUser`.
     * @principle Enforces role-based access control, preventing unauthorized privilege escalation.
     */
    match /roles_admin/{uid} {
      allow get: if isOwner(uid) || isAdmin();
      allow list: if isAdmin();
      allow create: if isOwner(uid) && (!exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid)) || isAdmin());
      allow update: if false;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Manages property bookings.
     * @path /bookings/{bookingId}
     * @allow (create) A signed-in user can create a booking for themselves.
     * @allow (read) A user can read their own bookings. Admins can read all bookings.
     * @deny (update, delete) Bookings are immutable once created for this example.
     */
    match /bookings/{bookingId} {
      allow create: if request.auth.uid == request.resource.data.userId;
      allow read: if request.auth.uid == resource.data.userId || isAdmin();
      allow list: if isAdmin() || (request.query.where[0][0] == 'userId' && request.query.where[0][2] == request.auth.uid);
      allow update, delete: if false;
    }
    
    /**
     * @description Manages property listings.
     * @path /properties/{propertyId}
     */
    match /properties/{propertyId} {
      // Public users can only see approved properties.
      allow read, list: if resource.data.status == 'approved' || (request.query.where[0][0] == 'status' && request.query.where[0][2] == 'approved');
      
      // Admins can see all properties regardless of status.
      allow read, list: if isAdmin();
      
      // Owners can view their own properties regardless of status.
      allow read, list: if isOwner(resource.data.owner.id);

      // Users can create properties, but they must be 'pending'.
      allow create: if isOwner(request.resource.data.owner.id) && request.resource.data.status == 'pending';
      
      // Owners can update their own properties, but cannot change the status.
      allow update: if isOwner(resource.data.owner.id) && request.resource.data.status == resource.data.status;
      
      // Admins can update any field, including changing the status.
      allow update: if isAdmin();
      
      // Owners or Admins can delete.
      allow delete: if isOwner(resource.data.owner.id) || isAdmin();
    }
    
    /**
     * @description Manages visit requests for properties.
     * @path /visits/{visitId}
     */
    match /visits/{visitId} {
        allow create: if isOwner(request.resource.data.userId);
        
        allow read: if isOwner(resource.data.userId) || isAdmin() || isPropertyOwner(resource.data.propertyId);
        
        allow list: if isAdmin() || 
                       (request.query.where[0][0] == 'userId' && request.query.where[0][2] == request.auth.uid) ||
                       (request.query.where[0][0] == 'propertyId' && isPropertyOwner(request.query.where[0][2]));

        allow update: if isPropertyOwner(resource.data.propertyId) || isAdmin();

        allow delete: if isOwner(resource.data.userId) || isPropertyOwner(resource.data.propertyId) || isAdmin();
    }

    /**
     * @description Manages global application settings.
     * @path /settings/global
     */
    match /settings/global {
      allow read, write: if isAdmin();
    }

    /**
     * @description Manages system-wide announcements.
     * @path /announcements/{announcementId}
     */
    match /announcements/{announcementId} {
      allow read, write: if isAdmin();
    }
  }
}

    